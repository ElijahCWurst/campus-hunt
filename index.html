<!--

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Tommy Fan Club</title>
    <style>
        /* --- 1. RESET & DARK THEME --- */
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            /* dvh = Dynamic Viewport Height (Fixes iPhone URL bar shift) */
            height: 100dvh;
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        /* --- 2. LANDSCAPE WARNING --- */
        #landscape-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
        }

        @media screen and (orientation: portrait) {
            #landscape-warning {
                display: flex;
            }
        }

        .rotate-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(-90deg);
            }
        }

        /* --- 3. START SCREEN --- */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            z-index: 5000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #start-btn {
            padding: 15px 30px;
            font-size: 1.5rem;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(211, 47, 47, 0.4);
        }

        #ios-note {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #888;
            max-width: 300px;
            text-align: center;
        }

        /* --- NEW: COUNTDOWN SCREEN --- */
        #countdown-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #121212;
            /* Higher than start screen (5000), lower than landscape warning (9999) */
            z-index: 6000; 
            display: flex; /* Flex is set here, but JS checks display property */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .countdown-title {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #timer {
            display: flex;
            gap: 15px;
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
        }

        .time-segment {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .time-label {
            font-size: 0.7rem;
            color: #555;
            font-weight: normal;
            margin-top: 5px;
        }

        /* --- 4. VIEWPORT LAYOUT --- */
        #viewport {
            width: 100vw;
            height: 100dvh;
            /* use dvh here too */
            overflow: hidden;
            position: relative;
            background-color: #222;
            display: grid;
            grid-template-columns: 40px auto;
            grid-template-rows: 40px auto;
        }

        /* The "Corner" (0,0) */
        #corner-block {
            grid-column: 1;
            grid-row: 1;
            background: #1e1e1e;
            z-index: 200;
            border-bottom: 1px solid #555;
            border-right: 1px solid #555;
        }

        /* STICKY HEADERS */
        #sticky-header-top {
            grid-column: 2;
            grid-row: 1;
            position: relative;
            overflow: hidden;
            background: #333;
            z-index: 100;
            border-bottom: 1px solid #555;
        }

        #axis-top-content {
            display: grid;
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }

        #sticky-header-left {
            grid-column: 1;
            grid-row: 2;
            position: relative;
            overflow: hidden;
            background: #333;
            z-index: 100;
            border-right: 1px solid #555;
        }

        #axis-left-content {
            display: grid;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
        }

        .axis-num,
        .axis-let {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            box-sizing: border-box;
            background: #333;
            overflow: hidden;
        }

        .axis-num {
            border-right: 1px solid #555;
        }

        .axis-let {
            border-bottom: 1px solid #555;
        }

        /* MAIN MAP AREA */
        #map-viewport {
            grid-column: 2;
            grid-row: 2;
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #world {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }

        #map-image {
            display: block;
            width: 1000px;
            height: auto;
            pointer-events: none;
        }

        #grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: grid;
        }

        .grid-cell {
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-sizing: border-box;
            cursor: pointer;
        }

        .grid-cell:active {
            background-color: rgba(255, 215, 0, 0.4);
            border: 1px solid gold;
        }

        /* --- 5. MODAL --- */
        #clue-modal {
            display: none;
            position: fixed;
            z-index: 6000;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        #modal-content {
            background-color: #1e1e1e;
            border: 1px solid #333;
            padding: 30px;
            border-radius: 12px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            position: relative;
            color: #fff;
        }

        #modal-title {
            margin-top: 0;
            color: #ff5252;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 30px;
            cursor: pointer;
            color: #888;
        }
    </style>
</head>

<body>

    <div id="landscape-warning">
        <div class="rotate-icon">â†»</div>
        <h2>Please Rotate Device</h2>
        <p>This map works best in landscape mode.</p>
    </div>

    <div id="countdown-screen">
        <div class="countdown-title">Fan Club Opens In</div>
        <div id="timer">
            <div class="time-segment">
                <span id="days">00</span>
                <span class="time-label">DAYS</span>
            </div>
            <div class="time-segment">:</div>
            <div class="time-segment">
                <span id="hours">00</span>
                <span class="time-label">HRS</span>
            </div>
            <div class="time-segment">:</div>
            <div class="time-segment">
                <span id="minutes">00</span>
                <span class="time-label">MIN</span>
            </div>
            <div class="time-segment">:</div>
            <div class="time-segment">
                <span id="seconds">00</span>
                <span class="time-label">SEC</span>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Campus Map</h1>
        <p>Tap below to enter fullscreen</p>
        <button id="start-btn">Start Hunt</button>
        <p id="ios-note">iPhone users: For best experience, tap Share > Add to Home Screen.</p>
    </div>

    <div id="viewport">
        <div id="corner-block"></div>
        <div id="sticky-header-top">
            <div id="axis-top-content"></div>
        </div>
        <div id="sticky-header-left">
            <div id="axis-left-content"></div>
        </div>
        <div id="map-viewport">
            <div id="world">
                <img id="map-image" src="./images/map_trimmed.PNG" alt="Map">
                <div id="grid-overlay"></div>
            </div>
        </div>
    </div>

    <div id="clue-modal">
        <div id="modal-content">
            <span class="close-btn">&times;</span>
            <h2 id="modal-title"></h2>
            <p id="modal-text"></p>
        </div>
    </div>

    <script>
        // --- COUNTDOWN LOGIC ---
        // I set this to Feb 13, 2026 to ensure the countdown shows for testing.
        // If you change this to a past date, the countdown will disappear immediately.
        // --- COUNTDOWN LOGIC (FIXED) ---
        const countDownDate = new Date("Feb 13, 2026 16:30:00").getTime();
        // const countDownDate = new Date("Feb 13, 2026 01:25:00").getTime();
        const countdownScreen = document.getElementById('countdown-screen');
        
        // 1. Declare the variable FIRST so the function can see it
        let timerInterval; 

        function updateTimer() {
            const now = new Date().getTime();
            const distance = countDownDate - now;

            // If timer is finished
            if (distance < 0) {
                // Safely clear the interval if it exists
                if (timerInterval) clearInterval(timerInterval);
                
                // Hide the countdown to reveal the start screen
                countdownScreen.style.display = 'none';
                return;
            }

            // Time calculations
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            // Output result
            document.getElementById("days").innerText = days < 10 ? "0" + days : days;
            document.getElementById("hours").innerText = hours < 10 ? "0" + hours : hours;
            document.getElementById("minutes").innerText = minutes < 10 ? "0" + minutes : minutes;
            document.getElementById("seconds").innerText = seconds < 10 ? "0" + seconds : seconds;
        }

        // 2. Run immediately to check if we should hide it instantly
        updateTimer();
        
        // 3. Start the loop (only runs if the function didn't return early)
        timerInterval = setInterval(updateTimer, 1000);

        // --- ORIGINAL APP CONFIGURATION ---
        const rows = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'];
        const colCount = 30;
        const mapBaseWidth = 1000;
        let mapBaseHeight = 0;

        // Dynamic Zoom Limits
        let MIN_SCALE = 0.4; // Will be overwritten by updateMinScale()
        const MAX_SCALE = 4.0;

        



        // --- DOM ELEMENTS ---
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const mapViewport = document.getElementById('map-viewport');
        const world = document.getElementById('world');
        const mapImage = document.getElementById('map-image');

        const axisTopContent = document.getElementById('axis-top-content');
        const axisLeftContent = document.getElementById('axis-left-content');
        const gridOverlay = document.getElementById('grid-overlay');
        const modal = document.getElementById('clue-modal');

        let state = {
            scale: 1, // Start zoomed in closer
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0
        };

        // --- INITIALIZATION ---
        function buildInterface() {
            gridOverlay.style.gridTemplateRows = `repeat(${rows.length}, 1fr)`;
            gridOverlay.style.gridTemplateColumns = `repeat(${colCount}, 1fr)`;
            axisTopContent.style.gridTemplateColumns = `repeat(${colCount}, 1fr)`;
            axisLeftContent.style.gridTemplateRows = `repeat(${rows.length}, 1fr)`;

            for (let r = 0; r < rows.length; r++) {
                const letDiv = document.createElement('div');
                letDiv.className = 'axis-let';
                letDiv.textContent = rows[r];
                axisLeftContent.appendChild(letDiv);

                for (let c = 1; c <= colCount; c++) {
                    if (r === 0) {
                        const numDiv = document.createElement('div');
                        numDiv.className = 'axis-num';
                        numDiv.textContent = c;
                        axisTopContent.appendChild(numDiv);
                    }
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.coord = rows[r] + c;
                    gridOverlay.appendChild(cell);
                }
            }
        }

        mapImage.onload = function () {
            const aspect = mapImage.naturalHeight / mapImage.naturalWidth;
            mapBaseHeight = mapBaseWidth * aspect;
            updateMinScale(); // Calculate limits immediately
            centerMap();
        };

        // Recalculate strict limits on resize
        window.addEventListener('resize', () => {
            updateMinScale();
            checkBoundaries(); // Re-clamp if window size changes
            setTransform();
        });

        // --- DYNAMIC LIMITS (Strict edge alignment) ---
        function updateMinScale() {
            const viewW = mapViewport.clientWidth;
            const viewH = mapViewport.clientHeight;

            // Calculate the scale needed to perfectly fit width or height
            const scaleW = viewW / mapBaseWidth;
            const scaleH = viewH / mapBaseHeight;

            // "Cover" logic: The map must be at least as big as the BIGGER dimension
            // so no black space ever shows.
            MIN_SCALE = Math.max(scaleW, scaleH);

            // If current scale is now illegal (too zoomed out), fix it
            if (state.scale < MIN_SCALE) state.scale = MIN_SCALE;
        }

        function checkBoundaries() {
            const viewW = mapViewport.clientWidth;
            const viewH = mapViewport.clientHeight;
            const currentMapW = mapBaseWidth * state.scale;
            const currentMapH = mapBaseHeight * state.scale;

            // STRICT CLAMPING
            // Max X is always 0 (Cannot move map right, creating gap on left)
            // Min X is ViewWidth - MapWidth (Cannot move map left, creating gap on right)

            const minX = viewW - currentMapW;
            const maxX = 0;
            const minY = viewH - currentMapH;
            const maxY = 0;

            if (state.pointX > maxX) state.pointX = maxX;
            if (state.pointX < minX) state.pointX = minX;

            if (state.pointY > maxY) state.pointY = maxY;
            if (state.pointY < minY) state.pointY = minY;
        }

        function setTransform() {
            checkBoundaries(); // Enforce strict limits
            world.style.transform = `translate(${state.pointX}px, ${state.pointY}px) scale(${state.scale})`;
            axisTopContent.style.width = (mapBaseWidth * state.scale) + 'px';
            axisTopContent.style.transform = `translateX(${state.pointX}px)`;
            axisLeftContent.style.height = (mapBaseHeight * state.scale) + 'px';
            axisLeftContent.style.transform = `translateY(${state.pointY}px)`;
        }

        function centerMap() {
            // Start centered
            const viewW = mapViewport.clientWidth;
            const viewH = mapViewport.clientHeight;

            // Start slightly zoomed in from the minimum
            state.scale = MIN_SCALE * 1.2;

            state.pointX = (viewW - mapBaseWidth * state.scale) / 2;
            state.pointY = (viewH - mapBaseHeight * state.scale) / 2;
            setTransform();
        }

        // --- EVENTS (Same interaction logic) ---
        startBtn.addEventListener('click', () => {
            const elem = document.documentElement;
            if (elem.requestFullscreen) { elem.requestFullscreen().catch(err => console.log(err)); }
            else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); }
            startScreen.style.display = 'none';

            // Small delay to let browser finish resizing for fullscreen
            setTimeout(() => {
                updateMinScale();
                centerMap();
            }, 200);
        });

        mapViewport.addEventListener('mousedown', (e) => {
            e.preventDefault();
            state.panning = true;
            state.startX = e.clientX - state.pointX;
            state.startY = e.clientY - state.pointY;
        });

        mapViewport.addEventListener('mousemove', (e) => {
            if (!state.panning) return;
            e.preventDefault();
            state.pointX = e.clientX - state.startX;
            state.pointY = e.clientY - state.startY;
            setTransform();
        });

        mapViewport.addEventListener('mouseup', () => { state.panning = false; });
        mapViewport.addEventListener('mouseleave', () => { state.panning = false; });

        mapViewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = mapViewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const xs = (mouseX - state.pointX) / state.scale;
            const ys = (mouseY - state.pointY) / state.scale;
            const delta = -e.deltaY;

            let newScale = (delta > 0) ? state.scale * 1.1 : state.scale / 1.1;

            if (newScale > MAX_SCALE) newScale = MAX_SCALE;
            if (newScale < MIN_SCALE) newScale = MIN_SCALE;

            state.pointX = mouseX - xs * newScale;
            state.pointY = mouseY - ys * newScale;
            state.scale = newScale;
            setTransform();
        }, { passive: false });

        let lastDist = 0;
        mapViewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                state.panning = true;
                state.startX = e.touches[0].clientX - state.pointX;
                state.startY = e.touches[0].clientY - state.pointY;
            } else if (e.touches.length === 2) {
                state.panning = false;
                lastDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }, { passive: false });

        mapViewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && state.panning) {
                state.pointX = e.touches[0].clientX - state.startX;
                state.pointY = e.touches[0].clientY - state.startY;
                setTransform();
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                if (lastDist === 0) { lastDist = dist; return; }

                const rect = mapViewport.getBoundingClientRect();
                const midX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
                const midY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;

                const scaleFactor = dist / lastDist;
                let newScale = state.scale * scaleFactor;

                if (newScale > MAX_SCALE) newScale = MAX_SCALE;
                if (newScale < MIN_SCALE) newScale = MIN_SCALE;

                const effectiveScaleFactor = newScale / state.scale;
                state.pointX = midX - (midX - state.pointX) * effectiveScaleFactor;
                state.pointY = midY - (midY - state.pointY) * effectiveScaleFactor;
                state.scale = newScale;
                lastDist = dist;
                setTransform();
            }
        }, { passive: false });

        mapViewport.addEventListener('touchend', () => { state.panning = false; lastDist = 0; });

        // --- CLUE LOGIC ---
        const clues = {
            "G9": "Timmy loves baseball. I'd recommend taking a swing at your next clue!",
            "F19": "I wonder what's in here...",
            "J19": "I think Tubby is looking to deposit his illicit dough! Better head into the offices and check the cashboxes!",
            "G24": "Maybe there's something waiting for me here...",
        };

        const emptyMessages = [
            "I wonder if there's more to this spot than meets the eye...",
            "This looks like a good place to hide something.",
            "I feel like I should take a closer look around here.",
            "Is there a pattern I'm not seeing yet?",
            "It's strangely quiet in this specific spot.",
            "I feel like I'm getting warmer...",
            "There is a certain energy in this area.",
            "What was that out of the corner of my eye?",
            "This perspective changes how the campus looks.",
            "Maybe I just need to look at this from a different angle.",
            "Does this location mean something specific?",
            "I have a feeling about this place."
        ];

        let touchStartTime = 0;

        // Trigger for Touchscreens
        gridOverlay.addEventListener('touchstart', () => {
            touchStartTime = Date.now();
        });

        // Trigger for Mouse (The Fix)
        gridOverlay.addEventListener('mousedown', () => {
            touchStartTime = Date.now();
        });

        gridOverlay.addEventListener('click', (e) => {
            // Calculate how long the press lasted
            const touchDuration = Date.now() - touchStartTime;

            // If press lasted longer than 300ms, assume it was a drag/pan and do nothing
            if (touchDuration > 300) return;

            // Otherwise, show the clue
            if (e.target.classList.contains('grid-cell')) {
                showClue(e.target.dataset.coord);
            }
        });

        function showClue(coord) {
            document.getElementById('modal-title').textContent = coord;
            
            let text;

            // Check if a specific clue exists for this coordinate
            if (clues[coord]) {
                text = clues[coord];
            } else {
                // If not, pick a random message from the emptyMessages array
                const randomIndex = Math.floor(Math.random() * emptyMessages.length);
                text = emptyMessages[randomIndex];
            }

            document.getElementById('modal-text').textContent = text;
            modal.style.display = 'flex';
        }

        document.querySelector('.close-btn').addEventListener('click', () => modal.style.display = 'none');
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });

        window.onload = buildInterface;

    </script>
</body>


</html>

-->



